const RAD2DEG = 57.295779513
function VectorAngles( forward, vOut )
{
	local yaw = 0.0;
	local pitch = yaw;

	if ( !forward.y && !forward.x )
	{
		if ( forward.z > 0.0 )
			pitch = 270.0;
		else
			pitch = 90.0;
	}
	else
	{
		yaw = atan2( forward.y, forward.x ) * RAD2DEG;
		if ( yaw < 0.0 )
			yaw += 360.0;

		pitch = atan2( -forward.z, forward.Length2D() ) * RAD2DEG;
		if ( pitch < 0.0 )
			pitch += 360.0;
	};

	vOut.x = pitch;
	vOut.y = yaw;
	vOut.z = 0.0;

	return vOut;
}
function UTIL_AngleMod(x){
	return x % 360;
}

function GetEnemyAimPosition( pEnemy )
{
	// Default to pointing to the origin
	local vecPos = Vector()

	local pTFEnemy = pEnemy

	// This is expensive, so only do it if our target is in a state that requires it
	if ( pTFEnemy )
	{
		local bShouldUseAccurateMethod = true; 

		//local playerFlags = pTFEnemy.GetFlags();
		// Crouch jumping makes your box weird
		//local bShouldUseAccurateMethod = !( playerFlags & Constants.FPlayer.FL_ONGROUND ) && ( playerFlags & Constants.FPlayer.FL_DUCKING );
		// Taunting can make your box weird
		//local bShouldUseAccurateMethod = pTFEnemy.InCond( Constants.ETFCond.TF_COND_TAUNTING );

		if ( bShouldUseAccurateMethod )
		{
			// Use this bone as the the aim target
			local iSpineBone = pTFEnemy.LookupBone( "bip_spine_2" );
			if ( iSpineBone != -1 )
			{
				vecPos = pTFEnemy.GetBoneOrigin(iSpineBone)
			}
		}
	}

	return vecPos;
}

function Track(){
	
	local vecMid = self.GetOrigin();
	local vecMidEnemy = GetEnemyAimPosition( m_hEnemy );
	local vecDirToEnemy = vecMidEnemy - vecMid;
	
	local angToTarget = QAngle();
	VectorAngles( vecDirToEnemy, angToTarget );
	
	angToTarget.y = UTIL_AngleMod( angToTarget.y );
	if (angToTarget.x < -180)
		angToTarget.x += 360;
	if (angToTarget.x > 180)
		angToTarget.x -= 360;
		
	// now all numbers should be in [1...360]
	// pin to turret limitations to [-50...50]
	if (angToTarget.x > 40)
		angToTarget.x = 40;
	else if (angToTarget.x < -65)
		angToTarget.x = -65;
	m_vecGoalAngles.y = angToTarget.y;
	m_vecGoalAngles.x = angToTarget.x;
	MoveCamera()
	return 0.01
}

function GetBaseTurnRate(){
	return m_iBaseTurnRate;
}

function MoveCamera(){
	local bMoved = false;
	local iBaseTurnRate = GetBaseTurnRate();
	
	// any x movement?
	
	if ( m_vecCurAngles.x != m_vecGoalAngles.x )
	{
		local flDir = (m_vecGoalAngles.x > m_vecCurAngles.x) ? 1 : -1 ;

		m_vecCurAngles.x += SENTRY_THINK_DELAY * ( iBaseTurnRate * 5 ) * flDir;

		// if we started below the goal, and now we're past, peg to goal
		if ( flDir == 1 )
		{
			if (m_vecCurAngles.x > m_vecGoalAngles.x)
				m_vecCurAngles.x = m_vecGoalAngles.x;
		} 
		else
		{
			if (m_vecCurAngles.x < m_vecGoalAngles.x)
				m_vecCurAngles.x = m_vecGoalAngles.x;
		}
		
		self.SetPoseParameter( m_iPitchPoseParameter, -m_vecCurAngles.x-12 );
		self.StudioFrameAdvance()
		bMoved = true;
	}
	
	if ( m_vecCurAngles.y != m_vecGoalAngles.y )
	{
		local flDir = (m_vecGoalAngles.y > m_vecCurAngles.y) ? 1 : -1 ;
		local flDist = fabs( m_vecGoalAngles.y - m_vecCurAngles.y );
		local bReversed = false;

		if ( flDist > 180 )
		{
			flDist = 360 - flDist;
			flDir = -flDir;
			bReversed = true;
		}

		if ( m_hEnemy == null )
		{
			if ( flDist > 30 )
			{
				if ( m_flTurnRate < iBaseTurnRate * 10 )
				{
					m_flTurnRate += iBaseTurnRate;
				}
			}
			else
			{
				// Slow down
				if ( m_flTurnRate > (iBaseTurnRate * 5) )
					m_flTurnRate -= iBaseTurnRate;
			}
		}
		else
		{
			// When tracking enemies, move faster and don't slow
			if ( flDist > 30 )
			{
				if (m_flTurnRate < iBaseTurnRate * 30)
				{
					m_flTurnRate += iBaseTurnRate * 3;
				}
			}
		}

		m_vecCurAngles.y += SENTRY_THINK_DELAY * m_flTurnRate * flDir;

		// if we passed over the goal, peg right to it now
		if (flDir == -1)
		{
			if ( (bReversed == false && m_vecGoalAngles.y > m_vecCurAngles.y) ||
				(bReversed == true && m_vecGoalAngles.y < m_vecCurAngles.y) )
			{
				m_vecCurAngles.y = m_vecGoalAngles.y;
			}
		} 
		else
		{
			if ( (bReversed == false && m_vecGoalAngles.y < m_vecCurAngles.y) ||
                (bReversed == true && m_vecGoalAngles.y > m_vecCurAngles.y) )
			{
				m_vecCurAngles.y = m_vecGoalAngles.y;
			}
		}

		if ( m_vecCurAngles.y < 0 )
		{
			m_vecCurAngles.y += 360;
		}
		else if ( m_vecCurAngles.y >= 360 )
		{
			m_vecCurAngles.y -= 360;
		}

		if ( flDist < ( SENTRY_THINK_DELAY * 0.5 * iBaseTurnRate ) )
		{
			m_vecCurAngles.y = m_vecGoalAngles.y;
		}

		local angles = self.EyeAngles();

		local flYaw = m_vecCurAngles.y - angles.y;
		
		self.SetPoseParameter( m_iYawPoseParameter, flYaw );
		self.StudioFrameAdvance()
		bMoved = true;
	}
	if ( !bMoved || m_flTurnRate <= 0 )
	{
		m_flTurnRate = iBaseTurnRate * 5;
	}
	
	return bMoved;
}


local camera = Entities.FindByName(null,"prp_camera_b")
camera.SetModel("models/props_interactive/posable/camera_security1.mdl")
camera.ValidateScriptScope()
camera.GetScriptScope().VectorAngles <- VectorAngles
camera.GetScriptScope().m_iPitchPoseParameter <- camera.LookupPoseParameter( "aim_pitch" );
camera.GetScriptScope().m_iYawPoseParameter <- camera.LookupPoseParameter( "aim_yaw" );
camera.GetScriptScope().m_iRightBound <- 45;
camera.GetScriptScope().m_iLeftBound <- 315;
camera.GetScriptScope().m_iBaseTurnRate <- 6;
camera.GetScriptScope().m_flFieldOfView <- 0.7;
camera.GetScriptScope().m_flTurnRate <- 0;
camera.GetScriptScope().m_hEnemy <- GetListenServerHost();
camera.GetScriptScope().m_vecCurAngles <- QAngle();
camera.GetScriptScope().m_vecGoalAngles <- QAngle();
camera.GetScriptScope().SENTRY_THINK_DELAY <- 0.05;
camera.GetScriptScope().UTIL_AngleMod <- UTIL_AngleMod;
camera.GetScriptScope().Track <- Track;
camera.GetScriptScope().MoveCamera <- MoveCamera;
camera.GetScriptScope().GetEnemyAimPosition <- GetEnemyAimPosition;


AddThinkToEnt(camera,"Track")
